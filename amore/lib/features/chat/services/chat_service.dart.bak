import 'dart:async';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:uuid/uuid.dart';

import '../../../core/services/firebase_service.dart';
import '../../../core/models/chat_model.dart';
import '../../../core/models/user_model.dart';
import '../../../core/app_config.dart';

/// å¯¦æ™‚èŠå¤©æœå‹™
class ChatService {
  static FirebaseFirestore get _firestore => FirebaseService.firestore;
  static FirebaseStorage get _storage => FirebaseService.storage;
  static const _uuid = Uuid();

  /// å‰µå»ºæˆ–ç²å–å°è©±
  static Future<ConversationModel?> createOrGetConversation({
    required String userId1,
    required String userId2,
    String? matchId,
  }) async {
    try {
      final conversationId = _generateConversationId(userId1, userId2);
      
      // æª¢æŸ¥å°è©±æ˜¯å¦å·²å­˜åœ¨
      final existingConversation = await getConversation(conversationId);
      if (existingConversation != null) {
        return existingConversation;
      }

      // å‰µå»ºæ–°å°è©±
      final conversation = ConversationModel(
        id: conversationId,
        participants: [userId1, userId2],
        type: ConversationType.match,
        createdAt: DateTime.now(),
        matchId: matchId,
      );

      await _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .set(conversation.toFirestore());

      // è¨˜éŒ„äº‹ä»¶
      await FirebaseService.logEvent(
        name: 'conversation_created',
        parameters: {
          'conversation_id': conversationId,
          'participants': [userId1, userId2],
          'match_id': matchId,
        },
      );

      return conversation;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'createOrGetConversation',
          'user_id_1': userId1,
          'user_id_2': userId2,
        },
      );
      return null;
    }
  }

  /// ç²å–å°è©±
  static Future<ConversationModel?> getConversation(String conversationId) async {
    try {
      final doc = await _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .get();

      if (doc.exists) {
        return ConversationModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  /// ç²å–ç”¨æˆ¶çš„å°è©±åˆ—è¡¨
  static Stream<List<ConversationModel>> getUserConversations(String userId) {
    return _firestore
        .collection(AppConstants.conversationsCollection)
        .where('participants', arrayContains: userId)
        .where('isActive', isEqualTo: true)
        .orderBy('lastMessageTime', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => ConversationModel.fromFirestore(doc))
            .toList());
  }

  /// ç™¼é€æ–‡å­—æ¶ˆæ¯
  static Future<MessageModel?> sendTextMessage({
    required String conversationId,
    required String senderId,
    required String content,
    String? replyToMessageId,
  }) async {
    return _sendMessage(
      conversationId: conversationId,
      senderId: senderId,
      content: content,
      type: MessageType.text,
      replyToMessageId: replyToMessageId,
    );
  }

  /// ç™¼é€åœ–ç‰‡æ¶ˆæ¯
  static Future<MessageModel?> sendImageMessage({
    required String conversationId,
    required String senderId,
    required File imageFile,
    String? caption,
  }) async {
    try {
      // ä¸Šå‚³åœ–ç‰‡åˆ° Firebase Storage
      final mediaUrl = await _uploadMedia(
        file: imageFile,
        conversationId: conversationId,
        type: 'image',
      );

      if (mediaUrl == null) return null;

      return _sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        content: caption ?? '',
        type: MessageType.image,
        mediaUrl: mediaUrl,
      );
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'sendImageMessage',
          'conversation_id': conversationId,
          'sender_id': senderId,
        },
      );
      return null;
    }
  }

  /// ç™¼é€èªéŸ³æ¶ˆæ¯
  static Future<MessageModel?> sendAudioMessage({
    required String conversationId,
    required String senderId,
    required File audioFile,
    required Duration duration,
  }) async {
    try {
      final mediaUrl = await _uploadMedia(
        file: audioFile,
        conversationId: conversationId,
        type: 'audio',
      );

      if (mediaUrl == null) return null;

      return _sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        content: '',
        type: MessageType.audio,
        mediaUrl: mediaUrl,
        metadata: {'duration': duration.inMilliseconds},
      );
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'sendAudioMessage',
          'conversation_id': conversationId,
          'sender_id': senderId,
        },
      );
      return null;
    }
  }

  /// ç²å–å°è©±æ¶ˆæ¯æµ
  static Stream<List<MessageModel>> getMessages(String conversationId) {
    return _firestore
        .collection(AppConstants.conversationsCollection)
        .doc(conversationId)
        .collection(AppConstants.messagesCollection)
        .orderBy('timestamp', descending: true)
        .limit(50)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => MessageModel.fromFirestore(doc))
            .toList());
  }

  /// ç²å–æ›´å¤šæ­·å²æ¶ˆæ¯
  static Future<List<MessageModel>> getMoreMessages({
    required String conversationId,
    required DateTime before,
    int limit = 20,
  }) async {
    try {
      final querySnapshot = await _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .collection(AppConstants.messagesCollection)
          .where('timestamp', isLessThan: Timestamp.fromDate(before))
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();

      return querySnapshot.docs
          .map((doc) => MessageModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// æ¨™è¨˜æ¶ˆæ¯ç‚ºå·²è®€
  static Future<void> markMessagesAsRead({
    required String conversationId,
    required String userId,
  }) async {
    try {
      final batch = _firestore.batch();

      // æ›´æ–°å°è©±çš„æœ€å¾Œé–±è®€æ™‚é–“
      final conversationRef = _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId);

      batch.update(conversationRef, {
        'lastReadTimes.$userId': FieldValue.serverTimestamp(),
        'unreadCounts.$userId': 0,
      });

      // ç²å–æœªè®€æ¶ˆæ¯ä¸¦æ¨™è¨˜ç‚ºå·²è®€
      final unreadMessages = await _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .collection(AppConstants.messagesCollection)
          .where('senderId', isNotEqualTo: userId)
          .where('status', isNotEqualTo: MessageStatus.read.toString())
          .get();

      for (final doc in unreadMessages.docs) {
        batch.update(doc.reference, {
          'status': MessageStatus.read.toString(),
        });
      }

      await batch.commit();

      // è¨˜éŒ„äº‹ä»¶
      await FirebaseService.logEvent(
        name: 'messages_read',
        parameters: {
          'conversation_id': conversationId,
          'user_id': userId,
          'message_count': unreadMessages.docs.length,
        },
      );
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'markMessagesAsRead',
          'conversation_id': conversationId,
          'user_id': userId,
        },
      );
    }
  }

  /// è¨­ç½®è¼¸å…¥ç‹€æ…‹
  static Future<void> setTypingStatus({
    required String conversationId,
    required String userId,
    required bool isTyping,
  }) async {
    try {
      final typingRef = _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .collection('typing')
          .doc(userId);

      if (isTyping) {
        await typingRef.set({
          'userId': userId,
          'isTyping': true,
          'timestamp': FieldValue.serverTimestamp(),
        });
      } else {
        await typingRef.delete();
      }
    } catch (e) {
      // è¼¸å…¥ç‹€æ…‹ä¸æ˜¯é—œéµåŠŸèƒ½ï¼Œå¤±æ•—æ™‚ä¸éœ€è¦éŒ¯èª¤è™•ç†
    }
  }

  /// ç²å–è¼¸å…¥ç‹€æ…‹æµ
  static Stream<List<TypingStatus>> getTypingStatus(String conversationId) {
    return _firestore
        .collection(AppConstants.conversationsCollection)
        .doc(conversationId)
        .collection('typing')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => TypingStatus.fromJson({
                  ...doc.data(),
                  'timestamp': (doc.data()['timestamp'] as Timestamp?)
                      ?.toDate()
                      .toIso8601String(),
                }))
            .where((status) => DateTime.now()
                    .difference(status.timestamp)
                    .inSeconds <
                5) // 5ç§’å…§çš„è¼¸å…¥ç‹€æ…‹æ‰æœ‰æ•ˆ
            .toList());
  }

  /// åˆªé™¤æ¶ˆæ¯
  static Future<bool> deleteMessage({
    required String conversationId,
    required String messageId,
    required String userId,
  }) async {
    try {
      final messageRef = _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .collection(AppConstants.messagesCollection)
          .doc(messageId);

      final messageDoc = await messageRef.get();
      if (!messageDoc.exists) return false;

      final message = MessageModel.fromFirestore(messageDoc);
      
      // åªæœ‰æ¶ˆæ¯ç™¼é€è€…æ‰èƒ½åˆªé™¤æ¶ˆæ¯
      if (message.senderId != userId) return false;

      await messageRef.delete();

      // å¦‚æœæ˜¯åª’é«”æ¶ˆæ¯ï¼ŒåŒæ™‚åˆªé™¤å­˜å„²çš„æ–‡ä»¶
      if (message.mediaUrl != null) {
        try {
          await _storage.refFromURL(message.mediaUrl!).delete();
        } catch (e) {
          // æ–‡ä»¶å¯èƒ½å·²ç¶“ä¸å­˜åœ¨ï¼Œå¿½ç•¥éŒ¯èª¤
        }
      }

      await FirebaseService.logEvent(
        name: 'message_deleted',
        parameters: {
          'conversation_id': conversationId,
          'message_id': messageId,
          'user_id': userId,
        },
      );

      return true;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'deleteMessage',
          'conversation_id': conversationId,
          'message_id': messageId,
          'user_id': userId,
        },
      );
      return false;
    }
  }

  /// å°é–ç”¨æˆ¶
  static Future<bool> blockUser({
    required String userId,
    required String blockedUserId,
    required String conversationId,
  }) async {
    try {
      // æ·»åŠ åˆ°å°é–åˆ—è¡¨
      await _firestore.collection(AppConstants.blocksCollection).add({
        'userId': userId,
        'blockedUserId': blockedUserId,
        'timestamp': FieldValue.serverTimestamp(),
        'reason': 'blocked_from_chat',
      });

      // éš±è—å°è©±
      await _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .update({
        'isActive': false,
      });

      await FirebaseService.logEvent(
        name: 'user_blocked',
        parameters: {
          'user_id': userId,
          'blocked_user_id': blockedUserId,
          'conversation_id': conversationId,
        },
      );

      return true;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'blockUser',
          'user_id': userId,
          'blocked_user_id': blockedUserId,
        },
      );
      return false;
    }
  }

  /// ç™¼é€æ¶ˆæ¯çš„å…§éƒ¨æ–¹æ³•
  static Future<MessageModel?> _sendMessage({
    required String conversationId,
    required String senderId,
    required String content,
    required MessageType type,
    String? mediaUrl,
    String? replyToMessageId,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final messageId = _uuid.v4();
      final now = DateTime.now();

      final message = MessageModel(
        id: messageId,
        conversationId: conversationId,
        senderId: senderId,
        content: content,
        type: type,
        timestamp: now,
        status: MessageStatus.sent,
        mediaUrl: mediaUrl,
        replyToMessageId: replyToMessageId,
        metadata: metadata,
      );

      final batch = _firestore.batch();

      // æ·»åŠ æ¶ˆæ¯
      final messageRef = _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId)
          .collection(AppConstants.messagesCollection)
          .doc(messageId);

      batch.set(messageRef, message.toFirestore());

      // æ›´æ–°å°è©±ä¿¡æ¯
      final conversationRef = _firestore
          .collection(AppConstants.conversationsCollection)
          .doc(conversationId);

      final conversation = await getConversation(conversationId);
      if (conversation != null) {
        final otherParticipant = conversation.getOtherParticipant(senderId);
        final currentUnreadCount = conversation.getUnreadCount(otherParticipant);

        batch.update(conversationRef, {
          'lastMessage': _getMessagePreview(content, type),
          'lastMessageTime': FieldValue.serverTimestamp(),
          'lastMessageSender': senderId,
          'updatedAt': FieldValue.serverTimestamp(),
          'unreadCounts.$otherParticipant': currentUnreadCount + 1,
        });
      }

      await batch.commit();

      // ç™¼é€æ¨é€é€šçŸ¥
      await _sendMessageNotification(conversationId, senderId, content, type);

      // è¨˜éŒ„äº‹ä»¶
      await FirebaseService.logEvent(
        name: 'message_sent',
        parameters: {
          'conversation_id': conversationId,
          'message_type': type.toString(),
          'has_media': mediaUrl != null,
        },
      );

      return message;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': '_sendMessage',
          'conversation_id': conversationId,
          'sender_id': senderId,
          'message_type': type.toString(),
        },
      );
      return null;
    }
  }

  /// ä¸Šå‚³åª’é«”æ–‡ä»¶
  static Future<String?> _uploadMedia({
    required File file,
    required String conversationId,
    required String type,
  }) async {
    try {
      final fileName = '${_uuid.v4()}.$type';
      final path = 'conversations/$conversationId/media/$fileName';
      
      final ref = _storage.ref().child(path);
      final uploadTask = ref.putFile(file);
      
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();
      
      return downloadUrl;
    } catch (e) {
      return null;
    }
  }

  /// ç”Ÿæˆå°è©±ID
  static String _generateConversationId(String userId1, String userId2) {
    final sortedIds = [userId1, userId2]..sort();
    return '${sortedIds[0]}_${sortedIds[1]}';
  }

  /// ç²å–æ¶ˆæ¯é è¦½æ–‡å­—
  static String _getMessagePreview(String content, MessageType type) {
    switch (type) {
      case MessageType.text:
        return content.length > 50 ? '${content.substring(0, 50)}...' : content;
      case MessageType.image:
        return 'ğŸ“· åœ–ç‰‡';
      case MessageType.audio:
        return 'ğŸµ èªéŸ³æ¶ˆæ¯';
      case MessageType.video:
        return 'ğŸ¥ è¦–é »';
      case MessageType.file:
        return 'ğŸ“ æ–‡ä»¶';
      case MessageType.location:
        return 'ğŸ“ ä½ç½®';
      case MessageType.sticker:
        return 'ğŸ˜Š è²¼åœ–';
      case MessageType.system:
        return content;
    }
  }

  /// ç™¼é€æ¶ˆæ¯æ¨é€é€šçŸ¥
  static Future<void> _sendMessageNotification(
    String conversationId,
    String senderId,
    String content,
    MessageType type,
  ) async {
    // é€™è£¡å¯¦ç¾æ¨é€é€šçŸ¥é‚è¼¯
    // å¯ä»¥ä½¿ç”¨ Firebase Cloud Messaging
    // éœ€è¦ç²å–æ¥æ”¶è€…çš„ FCM token ä¸¦ç™¼é€é€šçŸ¥
  }
} 