import 'dart:async';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:uuid/uuid.dart';

import '../../../core/services/firebase_service.dart';
import '../../../core/models/video_call_model.dart';
import '../../../core/app_config.dart';

/// è¦–é »é€šè©±æœå‹™
class VideoCallService {
  static const String _agoraAppId = 'YOUR_AGORA_APP_ID'; // éœ€è¦åœ¨ Agora æ§åˆ¶å°ç²å–
  static FirebaseFirestore get _firestore => FirebaseService.firestore;
  static const _uuid = Uuid();
  
  static RtcEngine? _engine;
  static StreamSubscription? _callSubscription;
  
  /// åˆå§‹åŒ– Agora å¼•æ“
  static Future<bool> initializeAgora() async {
    try {
      // æª¢æŸ¥å’Œè«‹æ±‚æ¬Šé™
      final cameraPermission = await Permission.camera.request();
      final microphonePermission = await Permission.microphone.request();
      
      if (cameraPermission != PermissionStatus.granted || 
          microphonePermission != PermissionStatus.granted) {
        if (AppConfig.enableDebugLogs) {
          print('âŒ è¦–é »é€šè©±æ¬Šé™è¢«æ‹’çµ•');
        }
        return false;
      }

      // å‰µå»º Agora å¼•æ“
      _engine = createAgoraRtcEngine();
      await _engine!.initialize(const RtcEngineContext(
        appId: _agoraAppId,
        channelProfile: ChannelProfileType.channelProfileCommunication,
      ));

      // å•Ÿç”¨è¦–é »æ¨¡çµ„
      await _engine!.enableVideo();
      await _engine!.enableAudio();

      if (AppConfig.enableDebugLogs) {
        print('âœ… Agora å¼•æ“åˆå§‹åŒ–æˆåŠŸ');
      }

      return true;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {'method': 'initializeAgora'},
      );
      return false;
    }
  }

  /// ç™¼èµ·è¦–é »é€šè©±
  static Future<VideoCallModel?> startVideoCall({
    required String callerId,
    required String receiverId,
    CallType type = CallType.video,
  }) async {
    try {
      if (_engine == null) {
        final initialized = await initializeAgora();
        if (!initialized) return null;
      }

      final callId = _uuid.v4();
      final channelName = 'call_$callId';

      // å‰µå»ºé€šè©±è¨˜éŒ„
      final call = VideoCallModel(
        id: callId,
        callerId: callerId,
        receiverId: receiverId,
        channelName: channelName,
        type: type,
        status: CallStatus.calling,
        createdAt: DateTime.now(),
      );

      await _firestore
          .collection(AppConstants.videoChatCollection)
          .doc(callId)
          .set(call.toFirestore());

      // ç™¼é€é€šè©±é€šçŸ¥çµ¦æ¥æ”¶è€…
      await _sendCallNotification(call);

      // è¨˜éŒ„äº‹ä»¶
      await FirebaseService.logEvent(
        name: 'video_call_initiated',
        parameters: {
          'call_id': callId,
          'caller_id': callerId,
          'receiver_id': receiverId,
          'call_type': type.toString(),
        },
      );

      return call;
    } catch (e, stackTrace) {
      await FirebaseService.recordError(
        exception: e,
        stackTrace: stackTrace,
        additionalData: {
          'method': 'startVideoCall',
          'caller_id': callerId,
          'receiver_id': receiverId,
        },
      );
      return null;
    }
  }

  /// æ¥è½é€šè©±
  static Future<bool> acceptCall(String callId) async {
    try {
      await _firestore
          .collection(AppConstants.videoChatCollection)
          .doc(callId)
          .update({
        'status': CallStatus.ongoing.toString(),
        'startedAt': FieldValue.serverTimestamp(),
      });

      await FirebaseService.logEvent(
        name: 'video_call_accepted',
        parameters: {'call_id': callId},
      );

      return true;
    } catch (e) {
      return false;
    }
  }

  /// æ‹’çµ•é€šè©±
  static Future<bool> declineCall(String callId, String reason) async {
    try {
      await _firestore
          .collection(AppConstants.videoChatCollection)
          .doc(callId)
          .update({
        'status': CallStatus.declined.toString(),
        'endedAt': FieldValue.serverTimestamp(),
        'endReason': reason,
      });

      await FirebaseService.logEvent(
        name: 'video_call_declined',
        parameters: {
          'call_id': callId,
          'reason': reason,
        },
      );

      return true;
    } catch (e) {
      return false;
    }
  }

  /// çµæŸé€šè©±
  static Future<bool> endCall(String callId, String endReason) async {
    try {
      final call = await getCall(callId);
      if (call == null) return false;

      int? duration;
      if (call.startedAt != null) {
        duration = DateTime.now().difference(call.startedAt!).inSeconds;
      }

      await _firestore
          .collection(AppConstants.videoChatCollection)
          .doc(callId)
          .update({
        'status': CallStatus.ended.toString(),
        'endedAt': FieldValue.serverTimestamp(),
        'duration': duration,
        'endReason': endReason,
      });

      // é›¢é–‹ Agora é »é“
      await _engine?.leaveChannel();

      await FirebaseService.logEvent(
        name: 'video_call_ended',
        parameters: {
          'call_id': callId,
          'duration': duration,
          'end_reason': endReason,
        },
      );

      return true;
    } catch (e) {
      return false;
    }
  }

  /// åŠ å…¥é€šè©±é »é“
  static Future<bool> joinChannel({
    required String channelName,
    required String token,
    required int uid,
  }) async {
    try {
      if (_engine == null) return false;

      await _engine!.joinChannel(
        token: token,
        channelId: channelName,
        uid: uid,
        options: const ChannelMediaOptions(),
      );

      return true;
    } catch (e) {
      return false;
    }
  }

  /// é›¢é–‹é€šè©±é »é“
  static Future<void> leaveChannel() async {
    try {
      await _engine?.leaveChannel();
    } catch (e) {
      // å¿½ç•¥é›¢é–‹é »é“çš„éŒ¯èª¤
    }
  }

  /// åˆ‡æ›æ”åƒé ­
  static Future<void> switchCamera() async {
    try {
      await _engine?.switchCamera();
    } catch (e) {
      // å¿½ç•¥éŒ¯èª¤
    }
  }

  /// é–‹é—œæ”åƒé ­
  static Future<void> toggleCamera(bool enabled) async {
    try {
      await _engine?.enableLocalVideo(enabled);
    } catch (e) {
      // å¿½ç•¥éŒ¯èª¤
    }
  }

  /// é–‹é—œéº¥å…‹é¢¨
  static Future<void> toggleMicrophone(bool enabled) async {
    try {
      await _engine?.enableLocalAudio(enabled);
    } catch (e) {
      // å¿½ç•¥éŒ¯èª¤
    }
  }

  /// é–‹é—œæ“´éŸ³å™¨
  static Future<void> toggleSpeaker(bool enabled) async {
    try {
      await _engine?.setEnableSpeakerphone(enabled);
    } catch (e) {
      // å¿½ç•¥éŒ¯èª¤
    }
  }

  /// ç²å–é€šè©±ä¿¡æ¯
  static Future<VideoCallModel?> getCall(String callId) async {
    try {
      final doc = await _firestore
          .collection(AppConstants.videoChatCollection)
          .doc(callId)
          .get();

      if (doc.exists) {
        return VideoCallModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  /// ç›£è½é€šè©±ç‹€æ…‹è®ŠåŒ–
  static Stream<VideoCallModel?> watchCall(String callId) {
    return _firestore
        .collection(AppConstants.videoChatCollection)
        .doc(callId)
        .snapshots()
        .map((snapshot) {
      if (snapshot.exists) {
        return VideoCallModel.fromFirestore(snapshot);
      }
      return null;
    });
  }

  /// ç›£è½ä¾†é›»
  static Stream<VideoCallModel?> listenForIncomingCalls(String userId) {
    return _firestore
        .collection(AppConstants.videoChatCollection)
        .where('receiverId', isEqualTo: userId)
        .where('status', isEqualTo: CallStatus.calling.toString())
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isNotEmpty) {
        return VideoCallModel.fromFirestore(snapshot.docs.first);
      }
      return null;
    });
  }

  /// ç²å–ç”¨æˆ¶çš„é€šè©±æ­·å²
  static Future<List<VideoCallModel>> getCallHistory(String userId) async {
    try {
      final querySnapshot = await _firestore
          .collection(AppConstants.videoChatCollection)
          .where('status', isEqualTo: CallStatus.ended.toString())
          .orderBy('createdAt', descending: true)
          .limit(50)
          .get();

      return querySnapshot.docs
          .map((doc) => VideoCallModel.fromFirestore(doc))
          .where((call) => call.callerId == userId || call.receiverId == userId)
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// è¨­ç½® Agora å¼•æ“äº‹ä»¶è™•ç†å™¨
  static void setAgoraEventHandlers({
    Function(RtcConnection connection, int remoteUid, int elapsed)? onUserJoined,
    Function(RtcConnection connection, int remoteUid, UserOfflineReasonType reason)? onUserOffline,
    Function(RtcConnection connection, RtcStats stats)? onRtcStats,
    Function(RtcConnection connection, ErrorCodeType err)? onError,
  }) {
    _engine?.registerEventHandler(
      RtcEngineEventHandler(
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          if (AppConfig.enableDebugLogs) {
            print('ğŸ¥ æˆåŠŸåŠ å…¥è¦–é »é€šè©±é »é“: ${connection.channelId}');
          }
        },
        onUserJoined: onUserJoined,
        onUserOffline: onUserOffline,
        onRtcStats: onRtcStats,
        onError: onError,
        onConnectionStateChanged: (RtcConnection connection, 
            ConnectionStateType state, ConnectionChangedReasonType reason) {
          if (AppConfig.enableDebugLogs) {
            print('ğŸ”— é€£æ¥ç‹€æ…‹è®ŠåŒ–: $state, åŸå› : $reason');
          }
        },
      ),
    );
  }

  /// ç™¼é€é€šè©±é€šçŸ¥
  static Future<void> _sendCallNotification(VideoCallModel call) async {
    // é€™è£¡å¯¦ç¾æ¨é€é€šçŸ¥é‚è¼¯
    // éœ€è¦ç²å–æ¥æ”¶è€…çš„ FCM token ä¸¦ç™¼é€é€šçŸ¥
    // é€šçŸ¥æ‡‰è©²åŒ…å«é€šè©±é¡å‹ã€ç™¼èµ·è€…ä¿¡æ¯ç­‰
  }

  /// ç”Ÿæˆ Agora Token
  /// æ³¨æ„ï¼šåœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œé€™æ‡‰è©²ç”±å¾Œç«¯æœå‹™ç”Ÿæˆ
  static Future<String?> generateAgoraToken({
    required String channelName,
    required int uid,
    required int expireTime,
  }) async {
    // é€™è£¡æ‡‰è©²èª¿ç”¨å¾Œç«¯ API ç”Ÿæˆ token
    // æš«æ™‚è¿”å› nullï¼Œè¡¨ç¤ºä½¿ç”¨ App ID é€²è¡Œæ¸¬è©¦
    return null;
  }

  /// é‡‹æ”¾è³‡æº
  static Future<void> dispose() async {
    try {
      await _callSubscription?.cancel();
      await _engine?.leaveChannel();
      await _engine?.release();
      _engine = null;
      
      if (AppConfig.enableDebugLogs) {
        print('ğŸ”Œ è¦–é »é€šè©±æœå‹™å·²æ¸…ç†');
      }
    } catch (e) {
      // å¿½ç•¥æ¸…ç†éŒ¯èª¤
    }
  }

  /// ç²å– Agora å¼•æ“å¯¦ä¾‹
  static RtcEngine? get engine => _engine;

  /// æª¢æŸ¥æ˜¯å¦æ”¯æŒè¦–é »é€šè©±
  static Future<bool> isVideoCallSupported() async {
    try {
      final cameraPermission = await Permission.camera.status;
      final microphonePermission = await Permission.microphone.status;
      
      return cameraPermission.isGranted && microphonePermission.isGranted;
    } catch (e) {
      return false;
    }
  }
} 